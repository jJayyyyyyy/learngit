
语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
a).BSS Segment(未初始化的全局变量)
b).Data Segment(已初始化的全局变量)



3、堆、自由存储区
由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，程序会一直占用内存，导致内存泄漏，在程序结束后，操作系统会自动回收。
由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来释放分配的内存。
4、常量存储区
这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。


例1：C语言程序

   int x;
   void main()  
   {
    }

变量x存储在内存哪个区域？
答：在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。
BSS是英文Block Started by Symbol的简称。BSS段属于静态存储区。

在采用段式内存管理的架构中，数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。


例2：static全局变量与普通全局变量有什么区别？
答：static全局变量和普通全局变量存储区域相同，不同的是：
static全局变量只在声明此static全局变量的文件中有效；
普通全局变量对整个源程序都有效，当此源程序包含多于一个文件的程序时，对其他文件依然有效。


例3：static局部变量与普通局部变量的区别？
答：static局部变量的存储区为静态存储区，普通局部变量的存储区为栈；
static局部变量生存周期为整个源程序，但是只能在声明其的函数中调用，并且其值与上一次的结果有关；而普通局部变量的生存周期为声明其函数的周期，超过特定的范围其值会被重新初始化；
static局部变量如果未初始化其值默认为0，而普通局部变量则不确定。


二、http://blog.chinaunix.net/uid-23516528-id-3826442.html
进程中内存空间的划分：
1.       代码区 – 存放代码/函数，只读区
2.       全局区 – 保存全局变量，读写区
3.       BSS段 – 未初始化的全局变量，BSS段在main执行前会自动清0
4.       栈区 – 存局部变量，包括函数形参，栈区的内存是自动分配自动回收的
5.       堆区 – 程序员自己管理的区域，malloc/ free操作的都是堆区。
6.       只读常量区 – 存放字符串常量和const修饰的全局变量。
注：只读常量区和代码区合并在一起。



三、 http://blog.sina.com.cn/s/blog_4762d68501010k6j.html
作用域 与 初始化
1.
全局变量：整个程序文件
静态全局变量：只在定义它的文件中有效
静态局部变量：只在定义它的函数内有效，程序分配一次内存，函数返回后仍然有效，直到程序结束才销毁，
局部变量：只在定义它的函数内有效，函数返回后就销毁。


2.初始化与作用域：
全局变量：如果没有初始化，那么自动初始化为0；作用域：整个程序运行期间。
全局静态变量：没有初始化则自动初始化为0，作用域是定义它的文件内有效。
局部静态变量：作用域也是定义它的函数内部，但是离开作用域后该变量没有销毁，直到程序运行结束才销毁。
静态函数：在函数前面加static关键字之后即是静态函数，同样只在定义它的文件内有效。
静态数据成员：同样是存储在静态存储区域，只能在类的申明中声明，在类的定义中定义该静态成员变量并初始化。
另外需要注意的是：1.静态成员变量遵循public, protected, private 访问规则。2.静态数据成员没有进入程序的全局空间，访问受到类的限制。
静态成员函数：
1）声明：在类的成员函数返回值之前加上关键字static，他就被声明为一个静态成员函数。静态成员函数不能声明为const或volatile，这与非静态成员函数不同。
2） 定义：出现在类体外的函数定义不能指定关键字static。
3） 作用：主要用于对静态数据成员的操作
4） 静态成员函数与类相联系，不与类的对象相联系。
5）静态成员函数不能访问非静态数据成员。因为非静态数据成员属于特定的类实例。
6）静态成员函数没有this指针，因此在静态成员函数中隐式或显示的引用这个指针都将导致编译时刻错误。试图访问隐式引用this指针的非静态数据成员也会导致编译时刻错误。
7）访问：可以用成员访问操作符(.)和箭头(->)为一个类对象或指向类对象的指针调用静态成员函数，也可以用限定修饰符名直接访问或调用静态成员函数，而无需声明类对象。

